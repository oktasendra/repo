MODULE potential

  use global_variables
  implicit none
  

  ! Functions to override
  logical, parameter :: run_init = .true.
  logical, parameter :: perturb_coordinates_override = .true.

!-----------Declare model globals here-----------!

  !Simulation parameters 
  INTEGER :: GRIDX, GRIDY, GRIDZ, N_PHASE, N_NODES, POT_RES, POT_EXTRA_DEPTH, POST_TYPE, CALL_POT, PAR
  INTEGER :: NPOSTX, NPOSTY, WIDTHX, WIDTHY, TOPEXX, TOPEXY, HEIGHT1, HEIGHT2, LIPX, LIPY, LIPZ, RES1, MENHEIGHT, N_CALLS
  INTEGER :: NPOSTXS, NPOSTYS, WIDTHXS, WIDTHYS
  DOUBLE PRECISION, ALLOCATABLE :: COORDSG(:), WEIGHT(:), SURFWEIGHT(:), EXTERNAL_POT(:), GRAVITY_POT(:) 
  DOUBLE PRECISION, ALLOCATABLE :: WETENERGY(:), WETTYPE(:)
  DOUBLE PRECISION :: PFGRIDSIZE, V0, CVOL, VOLUME, PRESSURE, PFEPSILON, CM1, PFCA1, POT_STRENGTH, POT_LAYER, UPFORCE,CSURF
  DOUBLE PRECISION :: CAP_SURFACE_TENSION, CAP_GRAVITY, CAP_PITCH, CAP_DENSITY
  REAL :: t1, t2
  
  LOGICAL :: CONSTVOL
  LOGICAL :: MENISCUS_STAT = .FALSE.
  INTEGER, ALLOCATABLE :: NODESTATE(:), NEIGHBS(:,:), PAIRSTATE(:,:), GSQCASE(:,:), POT_SIGN(:)
  LOGICAL  :: XSWITCH, YSWITCH, ZSWITCH, XMIRROR, YMIRROR, ZMIRROR, EXT_POT_STAT

!------------------------------------------------!


CONTAINS

!---------------------------------------------------------------------------------------------
! Wrappers
!---------------------------------------------------------------------------------------------
  !Wrapper for initialise system
  subroutine init()
    write(*,*) "InitWetting"
    call INITIALISE()
    write(*,*) "InitWetting end"
  end subroutine

  !Wrapper for computing the energy and gradient
  subroutine calc_energy_gradient()
    implicit none
   ! call COMPUTE_ENERGY_GRADIENT(X, G, E, .true.)
  end subroutine

  !Wrapper for perturbing the coordinates
  subroutine perturb_coordinates()
    IMPLICIT NONE
  end subroutine perturb_coordinates
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
! 1) Initialise the system
!---------------------------------------------------------------------------------------------
SUBROUTINE INITIALISE()
IMPLICIT NONE
INTEGER :: CUR, I, NUM, J1, J2, J3
CHARACTER(LEN=20) :: FN
REAL :: t1, t2

!Define the number of nodes
N_NODES=GRIDX*GRIDY*GRIDZ

!Alter switches if necessary
IF (GRIDX==1) THEN
	XSWITCH=.FALSE.
ELSE
	XSWITCH=.TRUE.
ENDIF

IF (GRIDY==1) THEN
	YSWITCH=.FALSE.
ELSE
	YSWITCH=.TRUE.
ENDIF

IF (GRIDZ==1) THEN
	ZSWITCH=.FALSE.
ELSE
	ZSWITCH=.TRUE.
ENDIF

!1.1) Allocate arrays
ALLOCATE(COORDSG(N_NODES),NODESTATE(N_NODES), NEIGHBS(N_NODES,6), PAIRSTATE(N_NODES,6), POT_SIGN(N_NODES))
ALLOCATE(WEIGHT(N_NODES), SURFWEIGHT(N_NODES),GSQCASE(N_NODES,3), EXTERNAL_POT(N_NODES), GRAVITY_POT(N_NODES))
!~ ALLOCATE(EXTERNAL_POT_1(GRIDX/2*GRIDY*GRIDZ), EXTERNAL_POT_2(N_NODES-GRIDX/2*GRIDY*GRIDZ+1))

COORDSG=0.0
NODESTATE=0
NEIGHBS=0
PAIRSTATE=0
WEIGHT=1.0
SURFWEIGHT=0.0
GSQCASE=0.0
VOLUME=0.0
EXTERNAL_POT=0.0
POT_SIGN=0


!1.2) Make the surface and assign all node values
CALL ASSIGN_NODES()

!1.3) Make the external potential
call cpu_time(t1)
IF (CALL_POT == 0) THEN
	CALL MAKE_EXTERNAL_POTENTIAL()
ELSEIF (CALL_POT /= 0) THEN
	OPEN(2,FILE='surf_pot.out', STATUS = 'old')
	DO CUR=1,N_NODES
		READ(2,'(F20.10)') EXTERNAL_POT(CUR)
	ENDDO
	CLOSE(2)
ENDIF
  
DO J1=1,GRIDX
  	DO J2=1,GRIDY
  		DO J3=1,GRIDZ
  			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3		
			IF (NODESTATE(CUR)>=0) THEN
				IF (EXTERNAL_POT(CUR)>=0) THEN
					POT_SIGN(CUR)=1
				ELSE
					POT_SIGN(CUR)=-1
				ENDIF
			ENDIF
		ENDDO
	ENDDO
ENDDO	

call cpu_time(t2)
PRINT '(" Time: ", f12.3, " min")', (t2 - t1)/60

!~ CALL MAKE_GRAVITY_POTENTIAL()

WEIGHT=WEIGHT*PFGRIDSIZE**3
SURFWEIGHT=SURFWEIGHT*PFGRIDSIZE**2
V0=V0*PFGRIDSIZE**3

!1.4) Convert surface contact angles to wetting energies
ALLOCATE(WETENERGY(N_NODES),WETTYPE(N_NODES))
DO CUR=1,N_NODES
	IF (PFCA1<=90.0) THEN
		WETTYPE(CUR)=1.0
		WETENERGY(CUR)=(SQRT(2.0)/6.0)*COS(PFCA1/180.0*ATAN(1.0D0) * 4.0D0)
	ELSE
		WETTYPE(CUR)=-1.0
		WETENERGY(CUR)=(SQRT(2.0)/6.0)*COS(PFCA1/180.0*ATAN(1.0D0) * 4.0D0)
	ENDIF
ENDDO

!1.5) Convert pressure in lattice unit
!~ PRESSURE=PRESSURE*SQRT(8.0/9.0)/(CAP_SURFACE_TENSION*1.0D-3)
!~ PRESSURE=PRESSURE*(CAP_PITCH*1.0D-6)/(GRIDY*1.0/NPOSTY*PFGRIDSIZE)

!~ PRINT *, "Pressure = ", PRESSURE

!1.6) Start the call counter
N_CALLS=0

END SUBROUTINE INITIALISE
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
! 2) Compute the energy and gradient
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_ENERGY_GRADIENT(COORDS, V, E, GTEST)
IMPLICIT NONE
DOUBLE PRECISION :: COORDS(N), V(N), E
LOGICAL :: GTEST
INTEGER :: CUR,J4, J1, J2, J3

N_CALLS = N_CALLS+1

!Debugging/run-checking. output the coordinates every 10000 steps
!~ IF (MOD(N_CALLS,10000)==0) THEN
!~ 	OPEN(12, FILE='coords'//TRIM(STR(N_CALLS))//'.step')
!~ 	WRITE(12,'(f20.10)') COORDSG
!~ 	CLOSE(12)
!~ ENDIF

!  !(2.-1) Fill all solid nodes with an arbitrary value (useful for plotting the results)
  DO J1 = 1, GRIDX
     DO J2 = 1, GRIDY
        DO J3 = 1, GRIDZ
           CUR = (J1-1)*GRIDY*GRIDZ + (J2-1)*GRIDZ + J3
		   IF (NODESTATE(CUR) ==-1) THEN
			   COORDS(CUR) = 0
		   ENDIF
!~ 		   IF (J3 >= GRIDZ - 2) THEN
!~ 			   COORDS(CUR) = -1					   
!~ 		   ENDIF
        ENDDO
     ENDDO
  ENDDO

COORDSG=COORDS


!2.1) Compute the energy
CALL COMPUTE_ENERGY(E)

!2.2) Compute the gradient
CALL COMPUTE_GRADIENT(V)

E=E*CM1
V=V*CM1

!~ Print *, E

!Test the gradinet against finite difference (COMMENT THIS IF NOT TESTING)
!~ CALL TEST_GRADIENT(V)



END SUBROUTINE COMPUTE_ENERGY_GRADIENT
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! 2.1) Compute the energy
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_ENERGY(E)
IMPLICIT NONE
INTEGER :: CUR, NEIGHBP, NEIGHBM, J1, J2, J3, GRIDX, GRIDY, GRIDZ
DOUBLE PRECISION :: E, EBULK, ESURF, EGRADSQ, GRADSQ, EVOL, RHOG, EPOT

E=0.0
EBULK=0.0
EGRADSQ=0.0
ESURF=0.0
EVOL=0.0
EPOT=0.0
VOLUME=0.0

!PRINT *,PRESSURE


!2.1.1) Bulk energy
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		EBULK=EBULK+( 0.25*COORDSG(CUR)**4 - 0.5*COORDSG(CUR)**2 + 0.25)*WEIGHT(CUR)/PFEPSILON
	ENDIF
ENDDO

		
!2.1.2) Gradient energy
!X-Gradients
IF (XSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,1))
			CASE (0)
				NEIGHBP=NEIGHBS(CUR,1)
				NEIGHBM=NEIGHBS(CUR,2)		
				GRADSQ=(COORDSG(NEIGHBP)-COORDSG(CUR))**2 + (COORDSG(CUR)-COORDSG(NEIGHBM))**2
				EGRADSQ=EGRADSQ+0.25*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			CASE (1)
				NEIGHBP=NEIGHBS(CUR,1)		
				GRADSQ=(COORDSG(NEIGHBP)-COORDSG(CUR))**2
				EGRADSQ=EGRADSQ+0.5*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			CASE (-1)
				NEIGHBM=NEIGHBS(CUR,2)		
				GRADSQ=(COORDSG(CUR)-COORDSG(NEIGHBM))**2
				EGRADSQ=EGRADSQ+0.5*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			END SELECT
		ENDIF
	ENDDO	
ENDIF


!Y-Gradients
IF (YSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,2))
			CASE (0)
				NEIGHBP=NEIGHBS(CUR,3)
				NEIGHBM=NEIGHBS(CUR,4)		
				GRADSQ=(COORDSG(NEIGHBP)-COORDSG(CUR))**2 + (COORDSG(CUR)-COORDSG(NEIGHBM))**2
				EGRADSQ=EGRADSQ+0.25*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			CASE (1)
				NEIGHBP=NEIGHBS(CUR,3)		
				GRADSQ=(COORDSG(NEIGHBP)-COORDSG(CUR))**2
				EGRADSQ=EGRADSQ+0.5*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			CASE (-1)
				NEIGHBM=NEIGHBS(CUR,4)		
				GRADSQ=(COORDSG(CUR)-COORDSG(NEIGHBM))**2
				EGRADSQ=EGRADSQ+0.5*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			END SELECT
		ENDIF
	ENDDO	
ENDIF


!Z-Gradients
IF (ZSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,3))
			CASE (0)
				NEIGHBP=NEIGHBS(CUR,5)
				NEIGHBM=NEIGHBS(CUR,6)		
				GRADSQ=(COORDSG(NEIGHBP)-COORDSG(CUR))**2 + (COORDSG(CUR)-COORDSG(NEIGHBM))**2
				EGRADSQ=EGRADSQ+0.25*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			CASE (1)
				NEIGHBP=NEIGHBS(CUR,5)		
				GRADSQ=(COORDSG(NEIGHBP)-COORDSG(CUR))**2
				EGRADSQ=EGRADSQ+0.5*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			CASE (-1)
				NEIGHBM=NEIGHBS(CUR,6)		
				GRADSQ=(COORDSG(CUR)-COORDSG(NEIGHBM))**2
				EGRADSQ=EGRADSQ+0.5*PFEPSILON*GRADSQ*WEIGHT(CUR)/PFGRIDSIZE**2
			END SELECT
		ENDIF
	ENDDO	
ENDIF


!2.1.3) Surface energy					
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)==1) THEN
	!	ESURF=ESURF+WETENERGY(CUR)*SURFWEIGHT(CUR)*&
	!	&(2.75-3*WETTYPE(CUR)*COORDSG(CUR)-1.5*COORDSG(CUR)**2+WETTYPE(CUR)*COORDSG(CUR)**3+0.75*COORDSG(CUR)**4 )
		
!~ 		ESURF=ESURF+EXTERNAL_POT(CUR)*SURFWEIGHT(CUR)*(0.75*COORDSG(CUR)-POT_SIGN(CUR)*COORDSG(CUR)**2/3.0&
!~ 		&-0.25*COORDSG(CUR)**3+POT_SIGN(CUR)*COORDSG(CUR)**4/6.0)
	ENDIF
ENDDO


!2.1.4) Volume/pressure constraints
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		VOLUME=VOLUME+0.5*(COORDSG(CUR)+1.0)*WEIGHT(CUR)	
	ENDIF
ENDDO


!2.1.5) External potential contribution	
   
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		!EPOT = EPOT + (COORDSG(CUR)+1.0)/2.0*WEIGHT(CUR)*(EXTERNAL_POT(CUR)+GRAVITY_POT(CUR))
		EPOT=EPOT+EXTERNAL_POT(CUR)*WEIGHT(CUR)*(0.75*COORDSG(CUR)-POT_SIGN(CUR)*COORDSG(CUR)**2/3.0&
		&-0.25*COORDSG(CUR)**3+POT_SIGN(CUR)*COORDSG(CUR)**4/6.0)
	ENDIF
ENDDO


IF (NODESTATE(CUR)>=0) THEN
	IF (CONSTVOL) THEN
	!Volume constraint
		EVOL = EVOL+CVOL*(V0-VOLUME)**2
	ELSE
	!Pressure constraint
		EVOL = EVOL-PRESSURE*VOLUME
	ENDIF
ENDIF

!2.1.5) Sum all energy contributions
E = EBULK+EGRADSQ+EVOL+ESURF+EPOT 


OPEN(24, FILE='volume.out')!, STATUS='old', POSITION='append',ACTION='write')
WRITE(24,*) VOLUME
CLOSE(24)

OPEN(24, FILE='evol.out')!, STATUS='old', POSITION='append',ACTION='write')
WRITE(24,*) EVOL
CLOSE(24)

OPEN(24, FILE='epot.out')!, STATUS='old', POSITION='append',ACTION='write')
WRITE(24,*) EPOT
CLOSE(24)

OPEN(24, FILE='esurf.out')!, STATUS='old', POSITION='append',ACTION='write')
WRITE(24,*) ESURF
CLOSE(24)

END SUBROUTINE COMPUTE_ENERGY
!---------------------------------------------------------------------------------------------




!---------------------------------------------------------------------------------------------
! 2.2) Compute the gradient
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_GRADIENT(V)
IMPLICIT NONE
DOUBLE PRECISION :: V(N)
INTEGER :: CUR, NEIGHBM, NEIGHBP, J1, J2, J3, GRIDX, GRIDY, GRIDZ

V=0.0

!2.1.1) Bulk gradient
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		V(CUR)=V(CUR)+( COORDSG(CUR)**3 - COORDSG(CUR) )*WEIGHT(CUR)/PFEPSILON
	ENDIF
ENDDO


!2.1.2) Gradient gradient
!X-Gradients
IF (XSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,1))
			CASE (0)
				NEIGHBP=NEIGHBS(CUR,1)
				NEIGHBM=NEIGHBS(CUR,2)	
	
				V(CUR)=V(CUR)+0.5*PFEPSILON/PFGRIDSIZE**2*( 2*COORDSG(CUR)-COORDSG(NEIGHBP)-COORDSG(NEIGHBM) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,1)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(NEIGHBP)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,2)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(NEIGHBM)
			CASE (1)
				NEIGHBP=NEIGHBS(CUR,1)
		
				V(CUR)=V(CUR)+PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,1)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(NEIGHBP)
			CASE (-1)
				NEIGHBM=NEIGHBS(CUR,2)
		
				V(CUR)=V(CUR)+PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,2)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(NEIGHBM)			
			END SELECT
		ENDIF
	ENDDO	
ENDIF

!Y-Gradients
IF (YSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,2))
			CASE (0)
				NEIGHBP=NEIGHBS(CUR,3)
				NEIGHBM=NEIGHBS(CUR,4)	
	
				V(CUR)=V(CUR)+0.5*PFEPSILON/PFGRIDSIZE**2*( 2*COORDSG(CUR)-COORDSG(NEIGHBP)-COORDSG(NEIGHBM) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,3)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(NEIGHBP)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,4)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(NEIGHBM)
			CASE (1)
				NEIGHBP=NEIGHBS(CUR,3)
		
				V(CUR)=V(CUR)+PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,3)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(NEIGHBP)
			CASE (-1)
				NEIGHBM=NEIGHBS(CUR,4)
		
				V(CUR)=V(CUR)+PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,4)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(NEIGHBM)			
			END SELECT
		ENDIF
	ENDDO	
ENDIF

!Z-Gradients
IF (ZSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,3))
			CASE (0)
				NEIGHBP=NEIGHBS(CUR,5)
				NEIGHBM=NEIGHBS(CUR,6)	
		
				V(CUR)=V(CUR)+0.5*PFEPSILON/PFGRIDSIZE**2*( 2*COORDSG(CUR)-COORDSG(NEIGHBP)-COORDSG(NEIGHBM) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,5)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(NEIGHBP)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,6)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(NEIGHBM)
			CASE (1)
				NEIGHBP=NEIGHBS(CUR,5)
				
				V(CUR)=V(CUR)+PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,5)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBP) )*WEIGHT(NEIGHBP)
			CASE (-1)
				NEIGHBM=NEIGHBS(CUR,6)
		
				V(CUR)=V(CUR)+PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(CUR)
				V(CUR)=V(CUR)+0.5*PAIRSTATE(CUR,6)*PFEPSILON/PFGRIDSIZE**2*( COORDSG(CUR)-COORDSG(NEIGHBM) )*WEIGHT(NEIGHBM)			
			END SELECT
		ENDIF
	ENDDO	
ENDIF




!2.1.3) Surface gradients					
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)==1) THEN
!		V(CUR)=V(CUR)+ WETENERGY(CUR)*SURFWEIGHT(CUR)*3.0*(-WETTYPE(CUR)-COORDSG(CUR)+WETTYPE(CUR)*COORDSG(CUR)**2+COORDSG(CUR)**3)
!~ 		V(CUR)=V(CUR)+EXTERNAL_POT(CUR)*SURFWEIGHT(CUR)*(0.75-POT_SIGN(CUR)*(2.0/3.0)*COORDSG(CUR)&
!~ 		&-0.75*COORDSG(CUR)**2+POT_SIGN(CUR)*(2.0/3.0)*COORDSG(CUR)**3)
	ENDIF
ENDDO


!2.1.4) Volume/pressure constraints
IF (CONSTVOL) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			V(CUR)=V(CUR) + CVOL*(VOLUME-V0)*WEIGHT(CUR)
		ENDIF
	ENDDO
ELSE
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			V(CUR)=V(CUR) - WEIGHT(CUR)*PRESSURE/2.0
		ENDIF
	ENDDO
ENDIF


!2.1.5) External potential contribution		

DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		!V(CUR)=V(CUR) + 0.5*WEIGHT(CUR)*EXTERNAL_POT(CUR)
		V(CUR)=V(CUR)+EXTERNAL_POT(CUR)*WEIGHT(CUR)*(0.75-POT_SIGN(CUR)*(2.0/3.0)*COORDSG(CUR)&
		&-0.75*COORDSG(CUR)**2+POT_SIGN(CUR)*(2.0/3.0)*COORDSG(CUR)**3)
	ENDIF
ENDDO

END SUBROUTINE COMPUTE_GRADIENT
!---------------------------------------------------------------------------------------------




!---------------------------------------------------------------------------------------------
! 1.2) Make the surface and assign all node values
!---------------------------------------------------------------------------------------------
SUBROUTINE ASSIGN_NODES()
IMPLICIT NONE
INTEGER :: J1,J2,J3,CUR, SURFSUM, PASS, SOLIDSUM, P1, P2, XSTART, XSTOP, YSTART, YSTOP
INTEGER :: P1S, P2S, P1Z, XSTARTS, XSTOPS, YSTARTS, YSTOPS, ZSTARTS, ZSTOPS
INTEGER :: CURXPYPZP,CURXPYPZ0,CURXPYPZM,CURXPY0ZP,CURXPY0Z0,CURXPY0ZM,CURXPYMZP,CURXPYMZ0,CURXPYMZM &
&,CURX0YPZP,CURX0YPZ0,CURX0YPZM,CURX0Y0ZP,CURX0Y0Z0,CURX0Y0ZM,CURX0YMZP,CURX0YMZ0,CURX0YMZM &
&,CURXMYPZP,CURXMYPZ0,CURXMYPZM,CURXMY0ZP,CURXMY0Z0,CURXMY0ZM,CURXMYMZP,CURXMYMZ0,CURXMYMZM
INTEGER :: NODESTATE0(N_NODES)

!1.2.1) Make the nodestate array
!1.2.1.1) Start by defining which nodes are solid nodes  - this can be changed depending on the surface. Currently set up for a complex post
		
! For large pillars

DO P1 = 1,NPOSTX
	DO P2 = 1, NPOSTY
		XSTART = INT((P1-1)*(GRIDX/NPOSTX)+1 + ((GRIDX/NPOSTX)-WIDTHX)/2)
		YSTART = INT((P2-1)*((GRIDY-RES1)/NPOSTY)+1 + RES1 + (((GRIDY-RES1)/NPOSTY)-WIDTHY)/2)
		XSTOP = XSTART+WIDTHX
		YSTOP = YSTART+WIDTHY
		
!~ 		PRINT *, XSTART, " ", XSTOP, " ", YSTART, " ", YSTOP
		
		DO J1 = (P1-1)*(GRIDX/NPOSTX)+1,P1*(GRIDX/NPOSTX)
			DO J2 = (P2-1)*((GRIDY-RES1)/NPOSTY)+1+RES1,P2*((GRIDY-RES1)/NPOSTY)+RES1
				DO J3=1,GRIDZ
					CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3

					!Make the surface at the base of the system 

					IF ( (J3==1) ) THEN !.OR. (J3==GRIDZ) ) THEN
						NODESTATE(CUR)=-1
					ENDIF

					!Make the central pillar for large pillar
					IF ( (J1>=XSTART) .AND. (J1<=XSTOP) .AND. (J2>YSTART) .AND. (J2<YSTOP) .AND. (J3<HEIGHT1+1) ) THEN
						NODESTATE(CUR)=-1
					ENDIF
					
!~ 					IF (P2==1) THEN
!~ 						HEIGHT1=20
!~ 						IF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTART) .AND. (J2<YSTOP) .AND. (J3<HEIGHT1+1) ) THEN
!~ 							NODESTATE(CUR)=-1
!~ 						ENDIF
!~ 					ENDIF
					
!~ 					IF (P2==2) THEN
!~ 						HEIGHT1=50
!~ 						IF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTART) .AND. (J2<YSTOP) .AND. (J3<HEIGHT1+1) ) THEN
!~ 							NODESTATE(CUR)=-1
!~ 						ENDIF
!~ 					ENDIF
					
!~ 					IF (P2==3) THEN
!~ 						HEIGHT1=40
!~ 						IF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTART) .AND. (J2<YSTOP) .AND. (J3<HEIGHT1+1) ) THEN
!~ 							NODESTATE(CUR)=-1
!~ 						ENDIF
!~ 					ENDIF			

!~ 					IF (P2==4) THEN
!~ 						HEIGHT1=10
!~ 						IF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTART) .AND. (J2<YSTOP) .AND. (J3<HEIGHT1+1) ) THEN
!~ 							NODESTATE(CUR)=-1
!~ 						ENDIF
!~ 					ENDIF
					
!~ 					IF (P2==5) THEN
!~ 						HEIGHT1=70
!~ 						IF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTART) .AND. (J2<YSTOP) .AND. (J3<HEIGHT1+1) ) THEN
!~ 							NODESTATE(CUR)=-1
!~ 						ENDIF
!~ 					ENDIF
					
				ENDDO
			ENDDO
		ENDDO
		
	ENDDO
ENDDO

IF (NPOSTYS /= 0) THEN
DO P1S = 1,NPOSTXS
	DO P2S = 1, NPOSTYS
		
		! For small pillars		
		XSTARTS = INT((P1S-1)*(GRIDX/NPOSTXS)+1 + ((GRIDX/NPOSTXS)-WIDTHXS)/2)
		YSTARTS = INT((P2S-1)*((GRIDY-RES1)/NPOSTYS)+1 + RES1 + (((GRIDY-RES1)/NPOSTYS)-WIDTHYS)/2)
		XSTOPS = XSTARTS+WIDTHXS
		YSTOPS = YSTARTS+WIDTHYS
			
		DO J1 = (P1S-1)*(GRIDX/NPOSTXS)+1,P1S*(GRIDX/NPOSTXS)
			DO J2 = (P2S-1)*((GRIDY-RES1)/NPOSTYS)+1+RES1,P2S*((GRIDY-RES1)/NPOSTYS)+RES1
				DO J3=1,GRIDZ
					CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3

					
					!Make the small pillar 
					IF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTART) .AND. (J2<YSTOP) ) THEN
						IF ( (J1>XSTARTS) .AND. (J1<XSTOPS) .AND. (J2>YSTARTS) .AND. (J2<YSTOPS) .AND. (J3<HEIGHT1+HEIGHT2+1) ) THEN
							NODESTATE(CUR)=-1
						ENDIF
					ELSE
						IF (P2S == 6 .OR. P2S == 13) THEN
							IF ( (J1>XSTARTS) .AND. (J1<XSTOPS) .AND. (J2>YSTARTS) .AND. (J2<YSTOPS) .AND. (J3<1+1) ) THEN
								NODESTATE(CUR)=-1
							ENDIF
						ELSE
							IF ( (J1>XSTARTS) .AND. (J1<XSTOPS) .AND. (J2>YSTARTS) .AND. (J2<YSTOPS) .AND. (J3<HEIGHT2+1) ) THEN
								NODESTATE(CUR)=-1
							ENDIF
						ENDIF
					ENDIF
					
					
					
				ENDDO
			ENDDO
		ENDDO
		
	ENDDO
ENDDO
ENDIF

IF (NPOSTYS /= 0) THEN		
DO P1 = 1,NPOSTX
	DO P2 = 1, NPOSTY
		DO P1Z = 1, INT(HEIGHT1/(GRIDY/NPOSTYS))
		! For large pillars
		XSTART = INT((P1-1)*(GRIDX/NPOSTX)+1 + ((GRIDX/NPOSTX)-WIDTHX)/2)
		YSTART = INT((P2-1)*((GRIDY-RES1)/NPOSTY)+1 + RES1 + (((GRIDY-RES1)/NPOSTY)-WIDTHY)/2)
		XSTOP = XSTART+WIDTHX
		YSTOP = YSTART+WIDTHY

		ZSTARTS = INT((P1Z-1)*(GRIDY/NPOSTYS))+1 + (((GRIDY/NPOSTYS)-WIDTHYS)/2)
		ZSTOPS = ZSTARTS+WIDTHYS
			
		DO J1 = (P1-1)*(GRIDX/NPOSTX)+1,P1*(GRIDX/NPOSTX)
			DO J2 = (P2-1)*((GRIDY-RES1)/NPOSTY)+1+RES1,P2*((GRIDY-RES1)/NPOSTY)+RES1
				DO J3=1,GRIDZ
					CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
		
					!Make vertical pillar
					IF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTART-HEIGHT2) .AND. (J2<YSTART+1) .AND. &
					& (J3>ZSTARTS) .AND. (J3<ZSTOPS) ) THEN
						NODESTATE(CUR)=-1
					ELSEIF ( (J1>XSTART) .AND. (J1<XSTOP) .AND. (J2>YSTOP-1) .AND. (J2<YSTOP+HEIGHT2) .AND. &
					& (J3>ZSTARTS) .AND. (J3<ZSTOPS) ) THEN
						NODESTATE(CUR)=-1
					ENDIF
					
				ENDDO
			ENDDO
		ENDDO
		
		ENDDO
	ENDDO	
ENDDO
ENDIF

	
NODESTATE0=NODESTATE

!1.2.1.2) Now automatically surround the solid nodes with surface nodes (pass 1) and calculate the node properties (pass 2) 
DO PASS=1,3
DO J1=1,GRIDX
	DO J2=1,GRIDY
		DO J3=1,GRIDZ
			!Define the neighbours in each direction
			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3

			CURXPYPZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPYPZ0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURXPYPZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXPY0ZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPY0Z0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURXPY0ZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXPYMZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPYMZ0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURXPYMZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0YPZP=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0YPZ0=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURX0YPZM=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0Y0ZP=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0Y0Z0=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURX0Y0ZM=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0YMZP=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0YMZ0=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURX0YMZM=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMYPZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMYPZ0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURXMYPZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMY0ZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMY0Z0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURXMY0ZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMYMZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMYMZ0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURXMYMZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			! Mirror symmetries (all we need to do is update the cardinal directions)
			
			! Mirror symmetry at the J1=1 and J1=GRIDX boundaries
			IF (XMIRROR) THEN
				IF (J1==1) THEN
					CURXMYPZP=CURX0YPZP
					CURXMYPZ0=CURX0YPZ0
					CURXMYPZM=CURX0YPZM

					CURXMY0ZP=CURX0Y0ZP
					CURXMY0Z0=CUR
					CURXMY0ZM=CURX0Y0ZM

					CURXMYMZP=CURX0YMZP
					CURXMYMZ0=CURX0YMZ0
					CURXMYMZM=CURX0YMZM
											
				ELSEIF (J1==GRIDX) THEN
					CURXPYPZP=CURX0YPZP
					CURXPYPZ0=CURX0YPZ0
					CURXPYPZM=CURX0YPZM

					CURXPY0ZP=CURX0Y0ZP
					CURXPY0Z0=CUR
					CURXPY0ZM=CURX0Y0ZM

					CURXPYMZP=CURX0YMZP
					CURXPYMZ0=CURX0YMZ0
					CURXPYMZM=CURX0YMZM
		
				ENDIF
			ENDIF
			
			! Mirror symmetry at the J2=1 and J2=GRIDY boundaries
			IF (YMIRROR) THEN
				IF (J2==1) THEN
					CURXPYMZP=CURXPY0ZP
					CURXPYMZ0=CURXPY0Z0
					CURXPYMZM=CURXPY0ZM
						
					CURX0YMZP=CURX0Y0ZP
					CURX0YMZ0=CUR
					CURX0YMZM=CURX0Y0ZM
						
					CURXMYMZP=CURXMY0ZP
					CURXMYMZ0=CURXMY0Z0
					CURXMYMZM=CURXMY0ZM

					
				ELSEIF (J2==GRIDY) THEN
					CURXPYPZP=CURXPY0ZP
					CURXPYPZ0=CURXPY0Z0
					CURXPYPZM=CURXPY0ZM
						
					CURX0YPZP=CURX0Y0ZP
					CURX0YPZ0=CUR
					CURX0YPZM=CURX0Y0ZM
						
					CURXMYPZP=CURXMY0ZP
					CURXMYPZ0=CURXMY0Z0
					CURXMYPZM=CURXMY0ZM
		
				ENDIF
			ENDIF		
				
			! Mirror symmetry at the J3=1 and J3=GRIDZ boundaries
			IF (ZMIRROR) THEN
				IF (J3==1) THEN
				
					CURXPYPZM=CURXPYPZ0
					CURXPY0ZM=CURXPY0Z0
					CURXPYMZM=CURXPYMZ0
						
					CURX0YPZM=CURX0YPZ0
					CURX0Y0ZM=CUR
					CURX0YMZM=CURX0YMZ0
						
					CURXMYPZM=CURXMYPZ0
					CURXMY0ZM=CURXMY0Z0
					CURXMYMZM=CURXMYMZ0

				ELSEIF (J3==GRIDZ) THEN
				
					CURXPYPZP=CURXPYPZ0
					CURXPY0ZP=CURXPY0Z0
					CURXPYMZP=CURXPYMZ0
						
					CURX0YPZP=CURX0YPZ0
					CURX0Y0ZP=CUR
					CURX0YMZP=CURX0YMZ0
						
					CURXMYPZP=CURXMYPZ0
					CURXMY0ZP=CURXMY0Z0
					CURXMYMZP=CURXMYMZ0		
				ENDIF
			ENDIF	
			
			IF (PASS==1) THEN
				!Calculate the sum of proximal solid nodes
				SURFSUM=0
				SURFSUM=NODESTATE0(CURXPYPZP)+NODESTATE0(CURXPYPZ0)+NODESTATE0(CURXPYPZM)&
&					+NODESTATE0(CURXPY0ZP)+NODESTATE0(CURXPY0Z0)+NODESTATE0(CURXPY0ZM)&
&					+NODESTATE0(CURXPYMZP)+NODESTATE0(CURXPYMZ0)+NODESTATE0(CURXPYMZM)&
&					+NODESTATE0(CURX0YPZP)+NODESTATE0(CURX0YPZ0)+NODESTATE0(CURX0YPZM)&
&					+NODESTATE0(CURX0Y0ZP)+NODESTATE0(CURX0Y0Z0)+NODESTATE0(CURX0Y0ZM)&
&					+NODESTATE0(CURX0YMZP)+NODESTATE0(CURX0YMZ0)+NODESTATE0(CURX0YMZM)&
&					+NODESTATE0(CURXMYPZP)+NODESTATE0(CURXMYPZ0)+NODESTATE0(CURXMYPZM)&
&					+NODESTATE0(CURXMY0ZP)+NODESTATE0(CURXMY0Z0)+NODESTATE0(CURXMY0ZM)&
&					+NODESTATE0(CURXMYMZP)+NODESTATE0(CURXMYMZ0)+NODESTATE0(CURXMYMZM)
				SURFSUM=-SURFSUM

				!Define surface node properties
				IF (SURFSUM>0) THEN
					!Indicate the surface node in NODESTATE
					IF (NODESTATE(CUR)>=0) THEN
						NODESTATE(CUR)=1
					ENDIF
				ENDIF
			
				!Update neighbour list
				NEIGHBS(CUR,:)=(/CURXPY0Z0,CURXMY0Z0,CURX0YPZ0,CURX0YMZ0,CURX0Y0ZP,CURX0Y0ZM/)

			ELSEIF (PASS==2) THEN

				IF (NODESTATE(CUR)==1) THEN
					IF ( (XSWITCH).AND.(YSWITCH).AND.(ZSWITCH) ) THEN
					!3D
						!Count the number of surface nodes in cardinal directions
						SURFSUM=0
						IF (NODESTATE(CURXPY0Z0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURXMY0Z0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0YPZ0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0YMZ0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0Y0ZP)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0Y0ZM)==1) SURFSUM=SURFSUM+1

						!Count the number of surface nodes in cardinal directions
						SOLIDSUM=0
						IF (NODESTATE(CURXPY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURXMY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YPZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YMZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZP)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZM)==-1) SOLIDSUM=SOLIDSUM+1

						!Compute the surface node properties
						IF ( (SURFSUM==3) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.875
							SURFWEIGHT(CUR)=0.75
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.75
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==5) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.625
							SURFWEIGHT(CUR)=1.25
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==1) ) THEN
							WEIGHT(CUR)=0.5
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==5) .AND. (SOLIDSUM==1) ) THEN
							WEIGHT(CUR)=0.375
							SURFWEIGHT(CUR)=1.25
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==2) ) THEN
							WEIGHT(CUR)=0.25
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==3) .AND. (SOLIDSUM==3) ) THEN
							WEIGHT(CUR)=0.125
							SURFWEIGHT(CUR)=0.75
						ELSEIF ( (SURFSUM==6) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=1.0
							SURFWEIGHT(CUR)=0.0
						ELSEIF ( (SURFSUM==2) .AND. (SOLIDSUM==4) ) THEN
							WEIGHT(CUR)=0.375
							SURFWEIGHT(CUR)=1.25
						ELSE
							PRINT *, 'ASSIGN_NODES> CASE NOT DEFINED AT NODE', CUR, 'J1, J2, J3 =',J1,J2,J3, 'SURFSUM', SURFSUM, 'SOLIDSUM', SOLIDSUM
						ENDIF

					ELSE
					!2D
						!Count the number of surface nodes in cardinal directions
						SOLIDSUM=0
						IF (NODESTATE(CURXPY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURXMY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YPZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YMZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZP)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZM)==-1) SOLIDSUM=SOLIDSUM+1

						!Compute the surface node properties
						IF (SOLIDSUM==0) THEN
							WEIGHT(CUR)=0.75
							SURFWEIGHT(CUR)=1.0
						ELSEIF (SOLIDSUM==1) THEN
							WEIGHT(CUR)=0.5
							SURFWEIGHT(CUR)=1.0
						ELSEIF (SOLIDSUM==2) THEN
							WEIGHT(CUR)=0.25
							SURFWEIGHT(CUR)=1.0
						ELSE
							PRINT *, 'ASSIGN_NODES> CASE NOT DEFINED AT NODE', CUR, 'J1, J2, J3 =',J1,J2,J3, 'SOLIDSUM', SOLIDSUM
						ENDIF
		
					ENDIF
				ENDIF				

			ELSEIF (PASS==3) THEN

				!Compute the pair properties between neighbours
				IF (NODESTATE(CUR)==0) THEN
					IF (NODESTATE(CURXPY0Z0)==1) THEN
						IF ( (WEIGHT(CURXPY0Z0)==0.625) .OR. (WEIGHT(CURXPY0Z0)==0.75) .OR. (WEIGHT(CURXPY0Z0)==0.875) ) THEN
							PAIRSTATE(CUR,1)=1
						ELSE
							PAIRSTATE(CUR,1)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,1)=1
					ENDIF

					IF (NODESTATE(CURXMY0Z0)==1) THEN
						IF ( (WEIGHT(CURXMY0Z0)==0.625) .OR. (WEIGHT(CURXMY0Z0)==0.75) .OR. (WEIGHT(CURXMY0Z0)==0.875) ) THEN
							PAIRSTATE(CUR,2)=1
						ELSE
							PAIRSTATE(CUR,2)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,2)=1
					ENDIF

					IF (NODESTATE(CURX0YPZ0)==1) THEN
						IF ( (WEIGHT(CURX0YPZ0)==0.625) .OR. (WEIGHT(CURX0YPZ0)==0.75) .OR. (WEIGHT(CURX0YPZ0)==0.875) ) THEN
							PAIRSTATE(CUR,3)=1
						ELSE
							PAIRSTATE(CUR,3)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,3)=1
					ENDIF
			
					IF (NODESTATE(CURX0YMZ0)==1) THEN
						IF ( (WEIGHT(CURX0YMZ0)==0.625) .OR. (WEIGHT(CURX0YMZ0)==0.75) .OR. (WEIGHT(CURX0YMZ0)==0.875) ) THEN
							PAIRSTATE(CUR,4)=1
						ELSE
							PAIRSTATE(CUR,4)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,4)=1
					ENDIF

					IF (NODESTATE(CURX0Y0ZP)==1) THEN
						IF ( (WEIGHT(CURX0Y0ZP)==0.625) .OR. (WEIGHT(CURX0Y0ZP)==0.75) .OR. (WEIGHT(CURX0Y0ZP)==0.875) ) THEN
							PAIRSTATE(CUR,5)=1
						ELSE
							PAIRSTATE(CUR,5)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,5)=1
					ENDIF

					IF (NODESTATE(CURX0Y0ZM)==1) THEN
						IF ( (WEIGHT(CURX0Y0ZM)==0.625) .OR. (WEIGHT(CURX0Y0ZM)==0.75) .OR. (WEIGHT(CURX0Y0ZM)==0.875) ) THEN
							PAIRSTATE(CUR,6)=1
						ELSE
							PAIRSTATE(CUR,6)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,6)=1
					ENDIF
				
				ELSEIF (NODESTATE(CUR)==1) THEN
					!Specific conditions for a neighboring surface normal facing back at the current node
					IF (WEIGHT(CURXPY0Z0)==0.125) THEN
						PAIRSTATE(CUR,1)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURXPY0Z0)==0.25) ) THEN
						PAIRSTATE(CUR,1)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURXPY0Z0)==0.375) ) THEN
						PAIRSTATE(CUR,1)=2
					ELSE
						!Not a corner
						PAIRSTATE(CUR,1)=1
					ENDIF

					IF (WEIGHT(CURXMY0Z0)==0.125) THEN
						PAIRSTATE(CUR,2)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURXMY0Z0)==0.25) ) THEN
						PAIRSTATE(CUR,2)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURXMY0Z0)==0.375) ) THEN
						PAIRSTATE(CUR,2)=2
					ELSE
						PAIRSTATE(CUR,2)=1
					ENDIF

					IF (WEIGHT(CURX0YPZ0)==0.125) THEN
						PAIRSTATE(CUR,3)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0YPZ0)==0.25) ) THEN
						PAIRSTATE(CUR,3)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0YPZ0)==0.375) ) THEN
						PAIRSTATE(CUR,3)=2
					ELSE
						PAIRSTATE(CUR,3)=1
					ENDIF

					IF (WEIGHT(CURX0YMZ0)==0.125) THEN
						PAIRSTATE(CUR,4)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0YMZ0)==0.25) ) THEN
						PAIRSTATE(CUR,4)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0YMZ0)==0.375) ) THEN
						PAIRSTATE(CUR,4)=2
					ELSE
						PAIRSTATE(CUR,4)=1
					ENDIF

					IF (WEIGHT(CURX0Y0ZP)==0.125) THEN
						PAIRSTATE(CUR,5)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0Y0ZP)==0.25) ) THEN
						PAIRSTATE(CUR,5)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0Y0ZP)==0.375) ) THEN
						PAIRSTATE(CUR,5)=2
					ELSE
						PAIRSTATE(CUR,5)=1
					ENDIF

					IF (WEIGHT(CURX0Y0ZM)==0.125) THEN
						PAIRSTATE(CUR,6)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0Y0ZM)==0.25) ) THEN
						PAIRSTATE(CUR,6)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0Y0ZM)==0.375) ) THEN
						PAIRSTATE(CUR,6)=2
					ELSE
						PAIRSTATE(CUR,6)=1
					ENDIF

				ENDIF


				!Fill the GSQCASE array
				IF (NODESTATE(CUR)==0) THEN
					GSQCASE(CUR,:)=0.0
				ELSEIF (NODESTATE(CUR)==1) THEN
					IF ( (NODESTATE(CURXPY0Z0)>=0) .AND. (NODESTATE(CURXMY0Z0)>=0) ) THEN
						GSQCASE(CUR,1)=0
					ELSEIF (NODESTATE(CURXPY0Z0)==-1) THEN
						GSQCASE(CUR,1)=-1
					ELSEIF (NODESTATE(CURXMY0Z0)==-1) THEN
						GSQCASE(CUR,1)=1
					ENDIF

					IF ( (NODESTATE(CURX0YPZ0)>=0) .AND. (NODESTATE(CURX0YMZ0)>=0) ) THEN
						GSQCASE(CUR,2)=0
					ELSEIF (NODESTATE(CURX0YPZ0)==-1) THEN
						GSQCASE(CUR,2)=-1
					ELSEIF (NODESTATE(CURX0YMZ0)==-1) THEN
						GSQCASE(CUR,2)=1
					ENDIF

					IF ( (NODESTATE(CURX0Y0ZP)>=0) .AND. (NODESTATE(CURX0Y0ZM)>=0) ) THEN
						GSQCASE(CUR,3)=0
					ELSEIF (NODESTATE(CURX0Y0ZP)==-1) THEN
						GSQCASE(CUR,3)=-1
					ELSEIF (NODESTATE(CURX0Y0ZM)==-1) THEN
						GSQCASE(CUR,3)=1
					ENDIF
				ENDIF
					


			ENDIF
			
	
		ENDDO
	ENDDO
ENDDO
ENDDO


!Debug: Output node arrays

OPEN(1,FILE='nodestate.out')
WRITE(1,'(1I10)') NODESTATE
 CLOSE(1)

OPEN(1,FILE='neighbs.out')
DO CUR=1,N_NODES
	WRITE(1,'(6I10)') NEIGHBS(CUR,:)
ENDDO
 CLOSE(1)

OPEN(1,FILE='weight.out')
WRITE(1,'(F20.10)') WEIGHT
 CLOSE(1)

OPEN(1,FILE='surfweight.out')
WRITE(1,'(F20.10)') SURFWEIGHT
 CLOSE(1)

OPEN(1,FILE='pairstate.out')
DO CUR=1,N_NODES
	WRITE(1,'(6I10)') PAIRSTATE(CUR,:)
ENDDO
 CLOSE(1)

OPEN(1,FILE='gsqcase.out')
DO CUR=1,N_NODES
	WRITE(1,'(3I10)') GSQCASE(CUR,:)
ENDDO
 CLOSE(1)

OPEN(1,FILE='surfnodes.out')
DO J1=1,GRIDX
	DO J2=1,GRIDY
		DO J3=1,GRIDZ
			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			IF ( (NODESTATE(CUR)==1) .OR. (NODESTATE(CUR)==-1)) THEN
				WRITE(1,*) J1, J2, J3
			ENDIF
		ENDDO
	ENDDO
ENDDO 
 CLOSE(1)

END SUBROUTINE ASSIGN_NODES
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! 1.3) Define the external potential at each node
!---------------------------------------------------------------------------------------------
SUBROUTINE MAKE_EXTERNAL_POTENTIAL()
IMPLICIT NONE
INTEGER :: J1, J2, J3, CUR, J1B, J2B, J3B, CURB, NPOINTS_APPROX, CURPOINT, J4, J1C, J2C, NIMAGEX, NIMAGEY
INTEGER :: J1BMIN, J1BMAX, J2BMIN, J2BMAX, J3BMIN, J3BMAX, TOTAL_POINTS
INTEGER, ALLOCATABLE :: POT_CELL(:,:,:), CONC_CELL(:,:,:)
DOUBLE PRECISION :: SEPARATION, PGAP, SNX, SNY, SNZ, SEPARATION_CUTOFF, SOLIDWEIGHT
DOUBLE PRECISION, ALLOCATABLE :: POT_POINTS(:,:), WEIGHT_CELL(:,:,:), WEIGHTS(:)


! 1.3.1) Make a list of 'potential points' - centres of the pointwise interaction potential
 ! Begin by approximating (overestimating) the number of potential points
 NPOINTS_APPROX=(SUM(NODESTATE**2)+POT_EXTRA_DEPTH*GRIDX*GRIDY)*(2*POT_RES-1)**3
 ALLOCATE(POT_POINTS(NPOINTS_APPROX,3))
 POT_POINTS(:,:)=0.0
 
 ALLOCATE(WEIGHTS(NPOINTS_APPROX))
 WEIGHTS(:)=1.0
 
 !Define the separation between points at a given resolution
 PGAP=1.0/(2.0*POT_RES-1)
 
 !Define the cut-off separation and number of images
!~  IF (POT_LAYER < 3) THEN
!~  		SEPARATION_CUTOFF=5*POT_LAYER
!~  	ELSEIF (POT_LAYER >= 3 .AND. POT_LAYER < 12) THEN
!~ 		SEPARATION_CUTOFF=4*POT_LAYER
!~ 	ELSEIF (POT_LAYER >=12 .AND. POT_LAYER < 21) THEN
!~ 		SEPARATION_CUTOFF=3*POT_LAYER
!~  ENDIF
 SEPARATION_CUTOFF=30*POT_LAYER
 
 !PRINT *,'SEP_CUTOFF = ', SEPARATION_CUTOFF
 !POT_EXTRA_DEPTH = POT_EXTRA_DEPTH*SEPARATION_CUTOFF
 PRINT*, "POT_EXTRA_DEPTH = ", POT_EXTRA_DEPTH

 NIMAGEX=CEILING(SEPARATION_CUTOFF/GRIDX)
 NIMAGEY=CEILING(SEPARATION_CUTOFF/GRIDY)

 
 !Convert the potential strenght and potential layer in lattice unit
	
 !Define a single cell (containing (2*POT_RES-1)**3 points). If POT_CELL(i,j,k)=1, this point will be included in the final list.
 ALLOCATE(POT_CELL(2*POT_RES-1,2*POT_RES-1,2*POT_RES-1),CONC_CELL(2*POT_RES-1,2*POT_RES-1,2*POT_RES-1))	
 ALLOCATE(WEIGHT_CELL(2*POT_RES-1,2*POT_RES-1,2*POT_RES-1))
 
	
 CURPOINT=1					
 DO J1=1,GRIDX
	DO J2=1,GRIDY
		DO J3=1,GRIDZ-1 ! <-- The top boundary in the system currently is just there to enforce zero z-gradient. Do not include long range forces from it
			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3

			IF ( (NODESTATE(CUR)==1) ) THEN
				POT_CELL(:,:,:)=2
 				WEIGHT_CELL(:,:,:)=1.0
 				
				! For surface nodes, we need to 'switch off' some points which go into the fluid region
!~ 				IF (NODESTATE(CUR)==1) THEN
					! If a neighbouring node is in the bulk, switch off all points in the fluid
					IF (NODESTATE(NEIGHBS(CUR,1))==0) THEN
						POT_CELL(POT_RES+1:2*POT_RES-1,:,:)=0
						WEIGHT_CELL(POT_RES,:,:)=1-0.5
					ENDIF
					IF (NODESTATE(NEIGHBS(CUR,2))==0) THEN
						POT_CELL(1:POT_RES-1,:,:)=0
						WEIGHT_CELL(POT_RES,:,:)=1-0.5
					ENDIF						
					IF (NODESTATE(NEIGHBS(CUR,3))==0)THEN
						POT_CELL(:,POT_RES+1:2*POT_RES-1,:)=0
						WEIGHT_CELL(:,POT_RES,:)=1-0.5
					ENDIF
					IF (NODESTATE(NEIGHBS(CUR,4))==0) THEN
						POT_CELL(:,1:POT_RES-1,:)=0
						WEIGHT_CELL(:,POT_RES,:)=1-0.5
					ENDIF
					IF (NODESTATE(NEIGHBS(CUR,5))==0) THEN
						POT_CELL(:,:,POT_RES+1:2*POT_RES-1)=0
						WEIGHT_CELL(:,:,POT_RES)=1-0.5
					ENDIF
					IF (NODESTATE(NEIGHBS(CUR,6))==0) THEN
						POT_CELL(:,:,1:POT_RES-1)=0
						WEIGHT_CELL(:,:,POT_RES)=1-0.5
					ENDIF	

					! Complete for all possible combination
					IF ( (WEIGHT(CUR)==0.75) ) THEN
						IF (NODESTATE(NEIGHBS(CUR,2))==0 .AND. NODESTATE(NEIGHBS(CUR,3))==0 ) THEN
							POT_CELL(1:POT_RES-1,POT_RES+1:2*POT_RES-1,:)=0
							WEIGHT_CELL(POT_RES,POT_RES,:)=0.25
						ENDIF	
						
						IF (NODESTATE(NEIGHBS(CUR,1))==0 .AND. NODESTATE(NEIGHBS(CUR,3))==0 ) THEN
							POT_CELL(POT_RES+1:2*POT_RES-1,POT_RES+1:2*POT_RES-1,:)=0
							WEIGHT_CELL(POT_RES,POT_RES,:)=0.25
						ENDIF
						IF (NODESTATE(NEIGHBS(CUR,4))==0 .AND. NODESTATE(NEIGHBS(CUR,5))==0 ) THEN
							POT_CELL(:,1:POT_RES-1,POT_RES+1:2*POT_RES-1)=0
							WEIGHT_CELL(:,POT_RES,POT_RES)=0.25
						ENDIF	
						
						IF (NODESTATE(NEIGHBS(CUR,3))==0 .AND. NODESTATE(NEIGHBS(CUR,5))==0 ) THEN
							POT_CELL(:,POT_RES+1:2*POT_RES-1,POT_RES+1:2*POT_RES-1)=0
							WEIGHT_CELL(:,POT_RES,POT_RES)=0.25
						ENDIF
					
					ENDIF

					!We also need to treat concave corners specially. The below algorithm locates nodes within the fluid.
					!After running through the IF statements, any point in CONC_CELL that > 0 is inside the fluid
					IF ( (WEIGHT(CUR)==0.125) .OR. (WEIGHT(CUR)==0.25) .OR. (WEIGHT(CUR)==0.375) ) THEN
						CONC_CELL(:,:,:)=2
						IF (NODESTATE(NEIGHBS(CUR,1))==-1) THEN
							CONC_CELL(POT_RES:2*POT_RES-1,:,:)=CONC_CELL(POT_RES:2*POT_RES-1,:,:)*0							
						ENDIF
						
						IF (NODESTATE(NEIGHBS(CUR,2))==-1) THEN
							CONC_CELL(1:POT_RES,:,:)=CONC_CELL(1:POT_RES,:,:)*0
						ENDIF
						
						IF (NODESTATE(NEIGHBS(CUR,3))==-1) THEN
							CONC_CELL(:,POT_RES:2*POT_RES-1,:)=CONC_CELL(:,POT_RES:2*POT_RES-1,:)*0							
						ENDIF
						
						IF (NODESTATE(NEIGHBS(CUR,4))==-1) THEN
							CONC_CELL(:,1:POT_RES,:)=CONC_CELL(:,1:POT_RES,:)*0
						ENDIF	
						
						IF (NODESTATE(NEIGHBS(CUR,5))==-1) THEN
							CONC_CELL(:,:,POT_RES:2*POT_RES-1)=CONC_CELL(:,:,POT_RES:2*POT_RES-1)*0							
						ENDIF
						
						IF (NODESTATE(NEIGHBS(CUR,6))==-1) THEN
							CONC_CELL(:,:,1:POT_RES)=CONC_CELL(:,:,1:POT_RES)*0
						ENDIF												
						
						
						!These corners are awkward and require a little more work
						IF (WEIGHT(CUR)==0.375) THEN
							IF (WEIGHT(NEIGHBS(CUR,1))==0.5) THEN
								CONC_CELL(1:POT_RES,:,:)=CONC_CELL(1:POT_RES,:,:)-1						
							ENDIF
							
							IF (WEIGHT(NEIGHBS(CUR,2))==0.5) THEN
								CONC_CELL(POT_RES:2*POT_RES-1,:,:)=CONC_CELL(POT_RES:2*POT_RES-1,:,:)-1	
							ENDIF
							
							IF (WEIGHT(NEIGHBS(CUR,3))==0.5) THEN
								CONC_CELL(:,1:POT_RES,:)=CONC_CELL(:,1:POT_RES,:)-1							
							ENDIF
							
							IF (WEIGHT(NEIGHBS(CUR,4))==0.5) THEN
								CONC_CELL(:,POT_RES:2*POT_RES-1,:)=CONC_CELL(:,POT_RES:2*POT_RES-1,:)-1
							ENDIF	
							
							IF (WEIGHT(NEIGHBS(CUR,5))==0.5) THEN
								CONC_CELL(:,:,1:POT_RES)=CONC_CELL(:,:,1:POT_RES)-1							
							ENDIF
							
							IF (WEIGHT(NEIGHBS(CUR,6))==0.5) THEN
								CONC_CELL(:,:,POT_RES:2*POT_RES-1)=CONC_CELL(:,:,POT_RES:2*POT_RES-1)-1
							ENDIF
							
						ENDIF	
						
						IF (WEIGHT(CUR)==0.25) THEN
							WEIGHT_CELL(POT_RES,POT_RES,POT_RES)=0.75
						ENDIF
						
						IF (WEIGHT(CUR)==0.125) THEN
							WEIGHT_CELL(POT_RES,POT_RES,POT_RES)=0.875
						ENDIF
						
						IF (WEIGHT(CUR)==0.375) THEN
							WEIGHT_CELL(POT_RES,POT_RES,POT_RES)=0.625
						ENDIF
						
						DO J1B=1,2*POT_RES-1
							DO J2B=1,2*POT_RES-1
								DO J3B=1,2*POT_RES-1
									IF (CONC_CELL(J1B,J2B,J3B)>=1) THEN
										POT_CELL(J1B,J2B,J3B)=0
									ENDIF
								ENDDO
							ENDDO
						ENDDO
	
					ENDIF
					
							
				IF (.NOT. XSWITCH) THEN
					POT_CELL(1:POT_RES-1,:,:)=0
					POT_CELL(POT_RES+1:2*POT_RES-1,:,:)=0
				ENDIF
				
				IF (.NOT. YSWITCH) THEN
					POT_CELL(:,1:POT_RES-1,:)=0
					POT_CELL(:,POT_RES+1:2*POT_RES-1,:)=0
				ENDIF				
			

				!Now loop over a cell, adding the points only if inside the solid
				DO J1B=1,2*POT_RES-1
					DO J2B=1,2*POT_RES-1
						DO J3B=1,2*POT_RES-1
							IF (POT_CELL(J1B,J2B,J3B)==2  ) THEN
								POT_POINTS(CURPOINT,1)=J1+0.5*(PGAP-1)+PGAP*(J1B-1)
								POT_POINTS(CURPOINT,2)=J2+0.5*(PGAP-1)+PGAP*(J2B-1)
								POT_POINTS(CURPOINT,3)=J3+0.5*(PGAP-1)+PGAP*(J3B-1)
								
								IF(WEIGHT_CELL(J1B,J2B,J3B)==0.5) THEN
									WEIGHTS(CURPOINT)= 0.5
								ELSEIF (WEIGHT_CELL(J1B,J2B,J3B)==0.25) THEN
									WEIGHTS(CURPOINT)= 0.25
								ELSEIF (WEIGHT_CELL(J1B,J2B,J3B)==0.75) THEN
									WEIGHTS(CURPOINT)= 0.75
								ELSEIF (WEIGHT_CELL(J1B,J2B,J3B)==0.875) THEN
									WEIGHTS(CURPOINT)=  0.875
								ELSEIF (WEIGHT_CELL(J1B,J2B,J3B)==0.625) THEN
									WEIGHTS(CURPOINT)= 0.625
								ENDIF
						        CURPOINT=CURPOINT+1
							ENDIF
						ENDDO
					ENDDO
				ENDDO
				


			ENDIF
			

			
			IF (NODESTATE(CUR)==-1) THEN
				POT_CELL(:,:,:)=1	
				
				!Account for 2D
				IF (.NOT. XSWITCH) THEN
					POT_CELL(1:POT_RES-1,:,:)=0
					POT_CELL(POT_RES+1:2*POT_RES-1,:,:)=0
				ENDIF
				
				IF (.NOT. YSWITCH) THEN
					POT_CELL(:,1:POT_RES-1,:)=0
					POT_CELL(:,POT_RES+1:2*POT_RES-1,:)=0
				ENDIF
			
				DO J1B=1,2*POT_RES-1
					DO J2B=1,2*POT_RES-1
						DO J3B=1,2*POT_RES-1
							IF (POT_CELL(J1B,J2B,J3B)==1) THEN
								POT_POINTS(CURPOINT,1)=J1+0.5*(PGAP-1)+PGAP*(J1B-1)
								POT_POINTS(CURPOINT,2)=J2+0.5*(PGAP-1)+PGAP*(J2B-1)
								POT_POINTS(CURPOINT,3)=J3+0.5*(PGAP-1)+PGAP*(J3B-1)
								CURPOINT=CURPOINT+1
							ENDIF
						ENDDO
					ENDDO
				ENDDO
			
			ENDIF
		ENDDO
	ENDDO
 ENDDO

 ! Now add additional layers of points below the system
 DO J1=1,GRIDX
	DO J2=1,GRIDY
		DO J3=1,POT_EXTRA_DEPTH
			POT_CELL(:,:,:)=1
		
			!Account for 2D
			IF (.NOT. XSWITCH) THEN
				POT_CELL(1:POT_RES-1,:,:)=0
				POT_CELL(POT_RES+1:2*POT_RES-1,:,:)=0
			ENDIF
			
			IF (.NOT. YSWITCH) THEN
				POT_CELL(:,1:POT_RES-1,:)=0
				POT_CELL(:,POT_RES+1:2*POT_RES-1,:)=0
			ENDIF				
				
			!Now loop over a cell, adding the extra points
			DO J1B=1,2*POT_RES-1
				DO J2B=1,2*POT_RES-1
					DO J3B=1,2*POT_RES-1
						IF (POT_CELL(J1B,J2B,J3B)==1) THEN
							POT_POINTS(CURPOINT,1)=J1+0.5*(PGAP-1)+PGAP*(J1B-1)
							POT_POINTS(CURPOINT,2)=J2+0.5*(PGAP-1)+PGAP*(J2B-1)
							POT_POINTS(CURPOINT,3)=1-J3+0.5*(PGAP-1)+PGAP*(J3B-1)
							CURPOINT=CURPOINT+1
						ENDIF
					ENDDO
				ENDDO
			ENDDO		
		ENDDO
	ENDDO
 ENDDO

 TOTAL_POINTS=CURPOINT-1
 Print *, 'total points = ', TOTAL_POINTS

 OPEN(1,FILE='pot_points.out')
 DO J1=1,NPOINTS_APPROX
 	WRITE(1,'(3F20.10)') POT_POINTS(J1,:), WEIGHTS(J1)
 ENDDO
 CLOSE(1)
 

! 1.3.2) Define the local potential
! At each node, define the external potential strength. This could be anything, for example gravity
! but here, we introduce a long range surface-fluid interaction potential. One way to do this is 
! outlined below, in which the potential at each fluid node is a sum of the interactions with each
! surface node.

! 1.3.2.1) Long-range surface-fluid interaction potential (Disjoining Pressure)
  
  DO J1=1,GRIDX
  	DO J2=1,GRIDY
  		DO J3=1,GRIDZ
  			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
  			IF (NODESTATE(CUR)>=0) THEN
				DO J4=1,TOTAL_POINTS
				
					IF (.NOT. XSWITCH) THEN
					!DO J2C = -INT(NIMAGEY/2)-1, INT(NIMAGEY/2)	!FO: Looping for images from -NIMAGEY to NIMAGEY if NIMAGEY>1
					 DO J2C = -NIMAGEY, NIMAGEY
						
	
						SNX=POT_POINTS(J4,1)
						SNY=POT_POINTS(J4,2) + J2C*GRIDY
						SNZ=POT_POINTS(J4,3)

						
						IF (SNY < J2-SEPARATION_CUTOFF .OR. SNY > J2+SEPARATION_CUTOFF) THEN 
							CYCLE
						ENDIF
	
						IF(SNX < J1-SEPARATION_CUTOFF .OR. SNX > J1+SEPARATION_CUTOFF) THEN 
							CYCLE 
						ENDIF
	
						! Calculate the separation bewteen the node and surface node
						SEPARATION=SQRT((J1-SNX)**2 + (J2-SNY)**2 + (J3-SNZ)**2)						
						EXTERNAL_POT(CUR) = EXTERNAL_POT(CUR)+SURF_POTENTIAL(SEPARATION)*(WEIGHTS(J4)*PFGRIDSIZE**3/(2*POT_RES-1)**3)
					ENDDO 	
				ELSE
!~ 					DO J1C = -INT(NIMAGEX/2)-1, INT(NIMAGEX/2)	!FO: Looping for images from -NIMAGEX to NIMAGEX if NIMAGEX>1
					DO J1C = -NIMAGEX, NIMAGEX 
				!		DO J2C = -INT(NIMAGEY/2)-1, INT(NIMAGEY/2)	!FO: Looping for images from -NIMAGEY to NIMAGEY if NIMAGEY>1
						DO J2C = -NIMAGEY, NIMAGEY
							
							SNX=POT_POINTS(J4,1) + J1C*GRIDX
							SNY=POT_POINTS(J4,2) + J2C*GRIDY
							SNZ=POT_POINTS(J4,3)
							
							IF (SNY <= J2-SEPARATION_CUTOFF .OR. SNY >= J2+SEPARATION_CUTOFF) THEN 
								CYCLE
							ENDIF

							IF(SNX <= J1-SEPARATION_CUTOFF .OR. SNX >= J1+SEPARATION_CUTOFF) THEN 
								CYCLE 
							ENDIF
							
							! Calculate the separation bewteen the node and surface node
							SEPARATION=SQRT(((J1-SNX)**2 + (J2-SNY)**2 + (J3-SNZ)**2)*PFGRIDSIZE**2)
							
							EXTERNAL_POT(CUR) = EXTERNAL_POT(CUR)+SURF_POTENTIAL(SEPARATION)*(WEIGHTS(J4))*PFGRIDSIZE**3/(2*POT_RES-1)**3

						ENDDO 	
					ENDDO
				ENDIF								
				ENDDO
			ENDIF
 							
		ENDDO
	ENDDO
  ENDDO		

  DO J1=1,GRIDX
  	DO J2=1,GRIDY
  		DO J3=1,GRIDZ
  			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3		
			IF (NODESTATE(CUR)>=0) THEN
				IF (EXTERNAL_POT(CUR)>=0) THEN
					POT_SIGN(CUR)=1
				ELSE
					POT_SIGN(CUR)=-1
				ENDIF
			ENDIF
		ENDDO
	ENDDO
  ENDDO	

  OPEN(1,FILE='surf_pot.out')
  WRITE(1,'(F20.10)') EXTERNAL_POT
  CLOSE(1)

!~   OPEN(1,FILE='surf_pot'//TRIM(STR(PAR))//'.out')
!~   WRITE(1,'(F20.10)') EXTERNAL_POT
!~   CLOSE(1)
  
! 1.3.3) We are done with the (potentially large) arrays of points
  DEALLOCATE(POT_POINTS,POT_CELL,CONC_CELL,WEIGHTS)


END SUBROUTINE MAKE_EXTERNAL_POTENTIAL
!---------------------------------------------------------------------------------------------

 !COMPUTE POTENTIAL DUE TO GRAVITY
SUBROUTINE MAKE_GRAVITY_POTENTIAL()
IMPLICIT NONE
INTEGER :: J1, J2, J3, CUR

! Convert the gravitational force to simulation units

UPFORCE=CAP_DENSITY*CAP_GRAVITY
UPFORCE=UPFORCE*SQRT(8.0/9.0)/(CAP_SURFACE_TENSION*1.0D-3)
UPFORCE=UPFORCE*((CAP_PITCH*1.0D-6)/(GRIDY*1.0/NPOSTY*PFGRIDSIZE))**2

!PRINT *, CAP_DENSITY, UPFORCE

DO J1 = 1, GRIDX
	DO J2 = 1, GRIDY
		DO J3 = 1, GRIDZ
			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			IF (NODESTATE(CUR)>=0) THEN
				GRAVITY_POT(CUR) = UPFORCE*(J2-1)*PFGRIDSIZE
			ENDIF
		ENDDO
	ENDDO
ENDDO	
   
!~ OPEN(1, FILE='gravity.out')
!~ WRITE(1,'(F20.10)') GRAVITY_POT
!~ CLOSE(1)

END SUBROUTINE MAKE_GRAVITY_POTENTIAL

!---------------------------------------------------------------------------------------------------------
!This function defines the surface-liquid interaction potential
FUNCTION SURF_POTENTIAL(SEP)
DOUBLE PRECISION :: SEP, SURF_POTENTIAL

!~ SURF_POTENTIAL=POT_STRENGTH/((SEP+POT_LAYER)*PFGRIDSIZE)**6
!~ IF (SEP < 20*sqrt(2.0)) THEN
SURF_POTENTIAL=POT_STRENGTH/(SEP+POT_LAYER*PFGRIDSIZE)**6 !- POT_STRENGTH/(20*sqrt(2.0)*PFGRIDSIZE+POT_LAYER*PFGRIDSIZE)**6
!~ ELSE
!~ SURF_POTENTIAL = 0
!~ ENDIF
END FUNCTION SURF_POTENTIAL
!---------------------------------------------------------------------------------------------------------

character(len=20) function str(k)
!   "Convert an integer to string."
    integer, intent(in) :: k
    write (str, *) k
    str = adjustl(str)
end function str

!---------------------------------------------------------------------------------------------------------------
!Test the gradient vs a finite difference approximation
SUBROUTINE TEST_GRADIENT(V)
IMPLICIT NONE
INTEGER :: CUR
DOUBLE PRECISION :: DT, A_0, A_P, A_M, E_P, E_M, TEST_GRAD(N), GRAD_DIFF(N), V(N)

DT=0.00001

DO CUR=1,N_NODES

		
	A_0 = COORDSG(CUR)
	A_P = COORDSG(CUR) + DT
	A_M = COORDSG(CUR) - DT

	E=0.0

	COORDSG(CUR) = A_P
	CALL COMPUTE_ENERGY(E)
	E_P=E

	COORDSG(CUR)=A_M
	CALL COMPUTE_ENERGY(E)
	E_M=E

	TEST_GRAD(CUR) = (E_P-E_M)/(2*DT)*CM1

	COORDSG(CUR) = A_0


	PRINT *, V(CUR), TEST_GRAD(CUR), V(CUR)-TEST_GRAD(CUR)
	IF (ABS(V(CUR)-TEST_GRAD(CUR))>=0.5) THEN
		PRINT *, 'STOP AT', CUR
		PRINT *, NODESTATE(CUR)
		PRINT *, GSQCASE(CUR,:)
		PRINT *, PAIRSTATE(CUR,:)

	 	 STOP
	ENDIF


ENDDO

GRAD_DIFF = V-TEST_GRAD
PRINT *, 'SUCCESS!', SUM(SQRT(GRAD_DIFF*GRAD_DIFF))

!stop

OPEN(1,FILE='grad.diff')
WRITE(1,'(F20.10)') GRAD_DIFF
CLOSE(1)

OPEN(1,FILE='grad.orig')
WRITE(1,'(F20.10)') G
CLOSE(1)

OPEN(1,FILE='grad.test')
WRITE(1,'(F20.10)') TEST_GRAD
CLOSE(1)

STOP

END SUBROUTINE TEST_GRADIENT


END MODULE potential
